<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="generator" content="pandoc">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <meta name="description" content="GGIS on Github : Organization Pages for Gary Dalton and GGIS">

          <meta name="author" content="Gary Dalton">
              <meta name="dcterms.date" content="2016-05-15">
          <title>Basic GPIO on the Raspberry Pi</title>
      <style type="text/css">code{white-space: pre;}</style>
      <!--[if lt IE 9]>
        <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
      <![endif]-->
                  <link rel="stylesheet" href="stylesheets/stylesheet.css">
            </head>

<body>
    
    <div id="header_wrap" class="outer">
    <header class="inner">
                <a id="forkme_banner" href="https://github.com/gary-dalton/RaspberryPi-projects/tree/gh-pages">View on GitHub</a>
                        <h1 id="project_title">Basic GPIO on the Raspberry Pi</h1>
                        <h3 id="project_tagline">I/O, Interrupts, and notifications</h3>
            </header>
    </div>

    <div id="main_content_wrap" class="outer">
    <section id="main_content" class="inner">
                <p><a href="index.html">Home</a></p>
<section id="description" class="level1">
<h1>Description</h1>
<p>This guide demonstrates basic use of Raspberry Pi GPIO. Our inputs will be a simple push button and temperature data read from an I2C DS3231 device (RTC). Our outputs will be LEDs and an Amazon Web Services - Simple Notification Services (SNS) endpoint.</p>
</section>
<section id="parts-list" class="level1">
<h1>Parts List</h1>
<ul>
<li>Raspberry Pi 2</li>
<li>MicroSD card</li>
<li><a href="http://www.amazon.com/s/ref=nb_sb_noss?url=search-alias%3Daps&amp;field-keywords=ds3231">DS3231M RTC Module</a></li>
<li><a href="http://www.amazon.com/s/ref=sr_nr_n_1?fst=as%3Aoff&amp;rh=n%3A5739464011%2Ck%3Apushbutton&amp;keywords=pushbutton&amp;ie=UTF8&amp;qid=1463408857&amp;rnid=2941120011">Pushbutton</a></li>
<li><a href="http://www.amazon.com/s/ref=sr_nr_n_2?fst=as%3Aoff&amp;rh=n%3A16310091%2Cn%3A306760011%2Ck%3Aled&amp;keywords=led&amp;ie=UTF8&amp;qid=1463409024&amp;rnid=16310161">LEDs</a></li>
</ul>
</section>
<section id="overview" class="level1">
<h1>Overview</h1>
<p>This guide assumes you have an installed and functioning Raspberry Pi with an installed RTC. If not please see the <a href="rpi_initial_setup.html">RPi Initial Setup Guide</a> and <a href="rpi_RTCds3231">RTC DS3231 on the Raspberry Pi</a>. It also assumes you are using SNS for notifications. If you do not have SNS, that portion may be easily skipped. Programs will be written in Python.</p>
<p>The steps to follow are:</p>
<ol type="1">
<li><a href="#1">Using GPIO for input and output</a></li>
<li><a href="#2">Using a GPIO interrupt</a></li>
<li><a href="#3">LEDs</a></li>
<li><a href="#4">Amazon Web Services - Simple Notification Services</a></li>
<li><p><a href="#5">Full example</a></p></li>
<li><a href="#6">Connect with VNC</a></li>
<li><a href="#7">Personalize your desktop</a></li>
<li><a href="#Conclusion">Conclusion</a></li>
<li><p><a href="#References">References</a></p></li>
</ol>
<section id="using-gpio-for-input-and-output" class="level2">
<h2><a name="1"></a>Using GPIO for input and output</h2>
<p><strong>WARNING: The pi must be powered down whenever you are connecting or disconnecting pins.</strong></p>
<p>Python's RPi.GPIO library supports using the GPIO pins on the pi. This library is instaled by default on recent versions of Raspbian. It is a good idea to review the <a href="https://sourceforge.net/p/raspberry-gpio-python/wiki/Home/">documentation for this library</a>.</p>
<p>The layout of the pins is shown below. Note that there are two numbering schemes and for programming you MUST choose either BOARD or BCM.</p>
<figure>
<img src="images/pi_gpio.jpg" alt="Pi GPIO pinouts" /><figcaption>Pi GPIO pinouts</figcaption>
</figure>
<p>To use a channel (pin), you must set it up. Output channels have fewer options than input channels.</p>
<section id="basic-channel-setup" class="level3">
<h3>Basic channel setup</h3>
<p>In the python example below, <em>channel</em> should be replaced by the appropriate pin number.</p>
<pre><code>import RPi.GPIO as GPIO

GPIO.setmode(GPIO.BOARD)
# or
# GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)

# Output with an optional initial GPIO.HIGH
GPIO.setup(channel, GPIO.OUT, initial=GPIO.HIGH)

# Multiple channels with 1 call (Use your own pin numbers)
channel_list = [31,32,33]
GPIO.setup(channel_list, GPIO.OUT)

# Inputs with pull-up resistors
GPIO.setup(channel_list, GPIO.IN, pull_up_down=GPIO.PUD_UP
</code></pre>
<p>Pull-up or pull-down resistors are needed to prevent the input from floating. Instead of using a physical resistor, this may by set as port of the GPIO.</p>
</section>
</section>
<section id="using-a-gpio-interrupt" class="level2">
<h2><a name="2"></a>Using a GPIO interrupt</h2>
<p>Interrupts are used to detect and act upon events. For example, you may wish to run a loop until a button is pressed. If the loop runs for 5 seconds, checking for the button press in the loop, called polling, would probably miss the button press. Instead, use event detection to capture the button press and check that status in the loop. Here is an example:</p>
<pre><code>import RPi.GPIO as GPIO
import smbus
import time

GPIO.setmode(GPIO.BOARD)
GPIO.setup(channel, GPIO.IN, pull_up_down = GPIO.PUD_UP)
GPIO.add_event_detect(channel, GPIO.RISING, bouncetime=200)

while not GPIO.event_detected(BUTTON):
    Celsius = getTemp(address)
    Fahrenheit = 9.0/5.0 * Celsius + 32
    print Fahrenheit, &quot;*F /&quot;, Celsius, &quot;*C&quot;
    time.sleep(10)</code></pre>
</section>
<section id="leds" class="level2">
<h2><a name="3"></a>LEDs</h2>
<p>Turning a light on with a circuit is a simple and effective way to check functioning and often leads directly to a product. LEDs have an anode and a cathode, meaning that current can only flow in one direction. LEDs also have very little resistance, meaning that they should be placed in series with a resistor in most circuits. LEDs have different specifications but a good resistor to place in series is 330 ohms.</p>
<p>On LEDs the longer lead is the anode and should be connected to the positive side of the circuit. If you don't recall and an easy way to check the functioning and color of an LED is to use a 3 volt button battery.</p>
<ul>
<li>View this<a href="https://learn.sparkfun.com/tutorials/light-emitting-diodes-leds">Sparkfun LED Tutorial</a></li>
</ul>
</section>
<section id="amazon-web-services---simple-notification-services" class="level2">
<h2><a name="4"></a>Amazon Web Services - Simple Notification Services</h2>
<p>Amazon SNS is a fast, flexible, fully managed publication-subscription messaging service. Use it as a cloud-based mobile app notification service to send push notifications, email, and SMS messages; or as an enterprise-messaging infrastructure.</p>
<p>This guide will not go into the details of SNS but assume that you have a functioning subscribed endpoint. Instead this guide will use boto3 to publish a message. The purpose of this is to demonstrate the connection of the virtual with the physical with the remote in the next section.</p>
<ul>
<li>Install boto3, <code>sudo pip install boto3</code></li>
<li>Enter your credentials into the configuration as shown in the <a href="https://boto3.readthedocs.io/en/latest/guide/quickstart.html">Boto3 Quickstart</a></li>
<li>Publish a message as shown:</li>
</ul>
<pre><code>import boto3
client =  boto3.client(&#39;sns&#39;)

# use your endpoint from Amazon
endpoint = &#39;arn:aws:sns:us-east-1:234567890:Alarms&#39;

#Send alert via SNS
response = client.publish(
    TopicArn=endpoint,
    Message=&#39;My Alert Message!&#39;)</code></pre>
<p>Those who have subscribed with an SMS phone number with receive and SMS text message. There are many other possible notifications that may be received.</p>
</section>
<section id="full-example" class="level2">
<h2><a name="5"></a>Full example</h2>
<figure>
<img src="images/clk_temp_lites_bb.png" alt="the circuit" /><figcaption>the circuit</figcaption>
</figure>
<p>The DS3231M has an operating temperature range of -45 C to 85 C. The RTC stores its temperature data in two registers. The upper 8 bits, representing an integer, are stored in two's complement form in register 11h. The lower 2 bits, representing the fractional portion, are in register 12h.</p>
<p>The RTC converts the temperature (updates the registers) every 64s. The maximum allowed by the chip is once every second. A convert may be forced by setting the CONV bit of the Control register (0Eh) to 1. Once the convert is completed, the CONV is set to 0 and the temperature may be read.</p>
<pre><code>## python
import smbus
import os
import RPi.GPIO as GPIO
import time
import random
import boto3

# Pins
LED_FLASH_LOW = 40
LED_GREEN = 38
LED_YELLOW = 37
LED_RED = 35
LED_FLASH_HIGH = 36
BUTTON = 33
LDR = 31

# Release RTC 3231
os.system(&#39;sudo rmmod rtc_ds1307&#39;)

# Setup RTC 3231 for temperature reading
bus = smbus.SMBus(1)
address = 0x68

# Force a conversion and wait until it completes
def convTemp(address):
    byte_control = bus.read_byte_data(address,0x0E)
    if byte_control &amp; 32 == 0:
        bus.write_byte_data(address, 0x0E, byte_control|32)
    byte_control = bus.read_byte_data(address,0x0E)
    while byte_control &amp; 32 != 0:
        time.sleep(1)
        byte_control = bus.read_byte_data(address,0x0E)
    return True

# Get temperature in degrees C
def getTemp(address):
    convTemp(address)
    byte_tmsb = bus.read_byte_data(address,0x11)
    byte_tlsb = bus.read_byte_data(address,0x12)
    tinteger = (byte_tmsb &amp; 0x7f) + ((byte_tmsb &amp; 0x80) &gt;&gt; 7) * -2**8
    tdecimal = (byte_tmsb &gt;&gt; 7) * 2**(-1) + ((byte_tmsb &amp; 0x40) &gt;&gt; 6) * 2**(-2)
    return tinteger + tdecimal

# Setup the AWS SNS client
client =  boto3.client(&#39;sns&#39;)
endpoint = &#39;arn:aws:sns:us-east-1:234567890:Alarm&#39;

##
#Work with LEDs
GPIO.setmode(GPIO.BOARD)
GPIO.setwarnings(False)

leds = [LED_FLASH_LOW,LED_GREEN,LED_YELLOW,LED_RED,LED_FLASH_HIGH]

# Temp in Fahrenheit
ALARM_LOW = 70
ALARM_OK = 80
ALARM_CAUTION = 90
ALARM_HIGH = 100

GPIO.setup(leds, GPIO.OUT)

#Use button to stop monitoring temperature
GPIO.setup(BUTTON, GPIO.IN, pull_up_down = GPIO.PUD_UP)
GPIO.add_event_detect(BUTTON, GPIO.RISING, bouncetime=200)

counter = 0
alert_low_clear = False
alert_high_clear = False
alert_critical_clear = False

while not GPIO.event_detected(BUTTON) and counter &lt; 100:
    Celsius = getTemp(address)
    Fahrenheit = 9.0/5.0 * Celsius + 32
    print Fahrenheit, &quot;*F /&quot;, Celsius, &quot;*C&quot;
    temperature = Fahrenheit
    if temperature &lt; ALARM_LOW:
        GPIO.output(leds, GPIO.LOW)
        GPIO.output(LED_FLASH_LOW, GPIO.HIGH)
        if alert_low_clear:
            #Send notification via AWS SNS
            response = client.publish(
                TopicArn=endpoint,
                Message=&#39;Temperature is low!&#39;)
            alert_low_clear = False
    elif temperature &lt; ALARM_OK:
        GPIO.output(leds, GPIO.LOW)
        GPIO.output(LED_GREEN, GPIO.HIGH)
        alert_low_clear = False
        alert_high_clear = False
        alert_critical_clear = False
    elif temperature &lt; ALARM_CAUTION:
        GPIO.output(leds, GPIO.LOW)
        GPIO.output(LED_YELLOW, GPIO.HIGH)
    elif temperature &lt; ALARM_HIGH:
        GPIO.output(leds, GPIO.LOW)
        GPIO.output(LED_RED, GPIO.HIGH)
        if alert_high_clear:
            #Send notification via AWS SNS
            response = client.publish(
                TopicArn=endpoint,
                Message=&#39;Temperature Alert!&#39;)
            alert_high_clear = False
    else:
        GPIO.output(leds, GPIO.LOW)
        GPIO.output([LED_RED, LED_FLASH_HIGH], GPIO.HIGH)
        if alert_critical_clear:
            #Send notification via AWS SNS
            response = client.publish(
                TopicArn=endpoint,
                Message=&#39;Temperature Critical! Meltdown Imminent&#39;)
            alert_critical_clear = False

    counter = counter + 1
    time.sleep(5)

#Run cleanup routines
print &quot;LEDs off&quot;
GPIO.output(leds, GPIO.LOW)
GPIO.cleanup()
os.system(&#39;sudo modprobe rtc_ds1307&#39;)</code></pre>
</section>
<section id="conclusion" class="level2">
<h2><a name="Conclusion"></a>Conclusion</h2>
<p>Your pi now as a battery backed, accurate RTC installed and working. This allows quality data-logging and other applications. Additionally, the temperature data from the RTC is available for your use.</p>
</section>
<section id="references" class="level2">
<h2><a name="References"></a>References</h2>
<ul>
<li><a href="rpi_RTCds3231">RTC DS3231 on the Raspberry Pi</a></li>
<li><a href="https://sourceforge.net/p/raspberry-gpio-python/wiki/BasicUsage/">RPi.GPIO module basics</a></li>
<li><a href="https://boto3.readthedocs.io/en/latest/reference/services/sns.html">Boto3 SNS</a></li>
<li><a href="https://www.element14.com/community/docs/DOC-78055/l/adding-a-shutdown-button-to-the-raspberry-pi-b">Adding a Shutdown Button to the Raspberry Pi B+</a></li>
</ul>
</section>
</section>
            </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
    <footer class="inner">
        <p>Published with <a href="http://pandoc.org/">Pandoc</a> onto
        <a href="https://pages.github.com">GitHub Pages</a></p>
    </footer>
    </div>

</body>
</html>
